import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.zN5fG3AC.js";const y=JSON.parse('{"title":"设计模式浅析(五) ·单例模式","description":"","frontmatter":{},"headers":[],"relativePath":"articles/designPatterns/05-设计模式之单例模式/设计模式之单例模式.md","filePath":"articles/designPatterns/05-设计模式之单例模式/设计模式之单例模式.md","lastUpdated":1713496484000}'),l={name:"articles/designPatterns/05-设计模式之单例模式/设计模式之单例模式.md"},t=n(`<h1 id="设计模式浅析-五-·单例模式" tabindex="-1">设计模式浅析(五) ·单例模式 <a class="header-anchor" href="#设计模式浅析-五-·单例模式" aria-label="Permalink to &quot;设计模式浅析(五) ·单例模式&quot;">​</a></h1><h2 id="日常叨逼叨" tabindex="-1">日常叨逼叨 <a class="header-anchor" href="#日常叨逼叨" aria-label="Permalink to &quot;日常叨逼叨&quot;">​</a></h2><p>java设计模式浅析，如果觉得对你有帮助，记得一键三连，谢谢各位观众老爷😁😁</p><hr><h2 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h2><h4 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h4><p><strong>单例模式</strong>确保一个类只有一个实例，并提供一个全局访问点。</p><h2 id="懒汉式-线程不安全" tabindex="-1">懒汉式：线程不安全 <a class="header-anchor" href="#懒汉式-线程不安全" aria-label="Permalink to &quot;懒汉式：线程不安全&quot;">​</a></h2><p>那么怎么构建一个单例模式，使得只返回唯一一个对象实例呢，我这里提供了一种方法</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //利用一个静态变量来记录SingleInstance类的唯一实例。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance singleInstance;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //把构造器声明为私有的，只有SingleInstance类内才可以调用构造器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //如果它不存在，我们就利用私有的构造器产生一个SingleInstance实例并把它赋值到singleInstance静态变量中。请注意，如果我们不需要这个实例，它就永远不会产生。这就是“延迟实例化”(laxy instantiaze)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (singleInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            singleInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //如果singleInstance不是null，就表示之前已经创建过对象。我们就直接跳到return语句。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> singleInstance;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>看起来好像是没有什么大的问题 思路清晰，代码明确。那么我们写如下代码进行测试</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Client</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 线程执行的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        SingleInstance instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; &lt;线程&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;正在运行&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Client myThread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Client</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            myThread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 启动线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>运行结果：</p><p>com.jerry.singlePattern.SingleInstance@294eb59e &lt;线程24正在运行&gt; com.jerry.singlePattern.SingleInstance@4c3154fa &lt;线程23正在运行&gt; com.jerry.singlePattern.SingleInstance@294eb59e &lt;线程20正在运行&gt; com.jerry.singlePattern.SingleInstance@294eb59e &lt;线程21正在运行&gt; com.jerry.singlePattern.SingleInstance@4add1757 &lt;线程22正在运行&gt;</p></blockquote><p>运行结果却有点出乎意料？？？我们不是单例模式吗？怎么创建出这么多的<code>SingleInstance</code>对象？？</p><blockquote><p>出现上述问题的原因是<strong>多线程</strong></p><p>在这个实现方式中，<code>getInstance()</code> 方法会检查 <code>singleInstance</code> 是否为 <code>null</code>，如果是则创建一个新的 <code>singleInstance</code> 实例。问题出在多个线程可能同时检查到 <code>singleInstance</code> 为 <code>null</code>，然后每个线程都创建一个新的实例，这就违背了单例模式的初衷。</p><p>具体来说，假设有两个线程 T1 和 T2 同时调用 <code>getInstance()</code> 方法。由于 <code>singleInstance</code> 的初始值为 <code>null</code>，T1 和 T2 都会进入 <code>if (singleInstance== null)</code> 的判断。由于这两个线程是并发执行的，它们可能会同时进入这个判断条件，并且都通过判断，然后各自创建一个新的 <code>singleInstance</code> 实例。这就导致了多个实例被创建，违反了单例模式的规则。</p></blockquote><h2 id="懒汉式-线程安全-同步方法" tabindex="-1">懒汉式：线程安全（同步方法） <a class="header-anchor" href="#懒汉式-线程安全-同步方法" aria-label="Permalink to &quot;懒汉式：线程安全（同步方法）&quot;">​</a></h2><p>我们可以将上述代码稍加修改，通过增加synchronized关键手到getInstance()方法中，我们迫使每个线程在进入这个方法之前，要先等候别的线程离开该方法。也就是说，不会有两个线程可以同时进入这个方法。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance2 singleInstance;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance2 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (singleInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            singleInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> singleInstance;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>运行结果：</p><p>com.jerry.singlePattern.SingleInstance2@5a506132 &lt;线程23正在运行&gt; com.jerry.singlePattern.SingleInstance2@5a506132 &lt;线程21正在运行&gt; com.jerry.singlePattern.SingleInstance2@5a506132 &lt;线程22正在运行&gt; com.jerry.singlePattern.SingleInstance2@5a506132 &lt;线程24正在运行&gt; com.jerry.singlePattern.SingleInstance2@5a506132 &lt;线程20正在运行&gt;</p></blockquote><p>虽然实现了同步，实现了单例，但是上述方法的确是有一点不好。而比想象的还要严重一些的是:只有第一次执行此方法时，才真正需要同步。换句话说，一旦设置好singleInstance变量，就不再需要同步这个方法了。之后每次调用这个方法，同步都是一种累赘。</p><h2 id="懒汉式-线程安全-双重检查锁定" tabindex="-1">懒汉式：线程安全（双重检查锁定） <a class="header-anchor" href="#懒汉式-线程安全-双重检查锁定" aria-label="Permalink to &quot;懒汉式：线程安全（双重检查锁定）&quot;">​</a></h2><p>那么在进行一些程序上的修改，利用双重检查加锁(double-checked locking)，首先检查是否实例已经创建了，如果尚未创建，“才”进行同步。这样一来，只有第一次会同步，这正是我们想要的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> volatile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance3 singleInstance;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance3 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (singleInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (SingleInstance3.class) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (singleInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    singleInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> singleInstance;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>运行结果：</p><p>com.jerry.singlePattern.SingleInstance3@1aef3070 &lt;线程24正在运行&gt; com.jerry.singlePattern.SingleInstance3@1aef3070 &lt;线程21正在运行&gt; com.jerry.singlePattern.SingleInstance3@1aef3070 &lt;线程20正在运行&gt; com.jerry.singlePattern.SingleInstance3@1aef3070 &lt;线程23正在运行&gt; com.jerry.singlePattern.SingleInstance3@1aef3070 &lt;线程22正在运行&gt;</p></blockquote><p>这种实现方式既保证了线程安全，又避免了不必要的同步，提高了效率。但是需要注意的是，Java 1.5 以前的版本对 volatile 的支持并不完善，因此在 Java 1.5 以前的版本中使用双重检查锁定可能会存在问题。</p><p>除了上述的几种方案，还有一些方案实现单例模式：</p><h2 id="饿汉式-线程安全" tabindex="-1">饿汉式：线程安全 <a class="header-anchor" href="#饿汉式-线程安全" aria-label="Permalink to &quot;饿汉式：线程安全&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance1 singleInstance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance1 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> singleInstance;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>运行结果</p><p>com.jerry.singlePattern.SingleInstance1@7070e0ed &lt;线程20正在运行&gt; com.jerry.singlePattern.SingleInstance1@7070e0ed &lt;线程24正在运行&gt; com.jerry.singlePattern.SingleInstance1@7070e0ed &lt;线程21正在运行&gt; com.jerry.singlePattern.SingleInstance1@7070e0ed &lt;线程23正在运行&gt; com.jerry.singlePattern.SingleInstance1@7070e0ed &lt;线程22正在运行&gt;</p></blockquote><p>在这个例子中，<code>SingleInstance1</code>类的<code>singleInstance</code>成员变量在类加载时就被初始化了，由于JVM的类加载机制是线程安全的，所以这个过程是线程安全的。因此，后续的<code>getInstance()</code>方法调用都是直接返回这个已经初始化好的<code>instance</code>，不需要额外的同步措施。</p><p>这就是饿汉式单例模式如何保证线程安全的方式。由于它在类加载时就完成了初始化，所以不存在多线程并发访问的问题，因此是线程安全的。</p><h4 id="静态内部类-线程安全" tabindex="-1">静态内部类：线程安全 <a class="header-anchor" href="#静态内部类-线程安全" aria-label="Permalink to &quot;静态内部类：线程安全&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingletonHolder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance4 INSTANCE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (){}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingleInstance4 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SingletonHolder.INSTANCE;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>运行结果</p><p>com.jerry.singlePattern.SingleInstance4@7004943 &lt;线程23正在运行&gt; com.jerry.singlePattern.SingleInstance4@7004943 &lt;线程20正在运行&gt; com.jerry.singlePattern.SingleInstance4@7004943 &lt;线程24正在运行&gt; com.jerry.singlePattern.SingleInstance4@7004943 &lt;线程21正在运行&gt; com.jerry.singlePattern.SingleInstance4@7004943 &lt;线程22正在运行&gt;</p></blockquote><p>静态内部类<code>SingletonHolder</code>中包含了一个静态字段<code>INSTANCE</code>，这个字段在静态内部类被加载时初始化。由于JVM的类加载机制保证了类的初始化过程是线程安全的，因此静态内部类中的静态字段只会被初始化一次，即在首次通过<code>getInstance()</code>方法访问时。这就确保了单例的懒加载和线程安全。</p><p>当<code>Singleton</code>类被加载时，<code>SingletonHolder</code>类并不会立即被加载。只有当调用<code>Singleton.getInstance()</code>方法时，<code>SingletonHolder</code>类才会被加载，此时会初始化<code>INSTANCE</code>字段。由于类的加载和初始化是由JVM在内部通过锁机制保证线程安全的，所以不需要额外的同步措施。</p><p>因此，静态内部类实现单例模式既能够实现懒加载，又能够利用JVM的类加载机制保证线程安全。这是单例模式中一种非常优雅且高效的实现方式。</p><h2 id="枚举-线程安全" tabindex="-1">枚举：线程安全 <a class="header-anchor" href="#枚举-线程安全" aria-label="Permalink to &quot;枚举：线程安全&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SingleInstance5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    INSTANCE_5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 如果需要，可以添加其他属性或方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String data;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 其他需要的方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>运行结果:</p><p>INSTANCE_5 &lt;线程20正在运行&gt; INSTANCE_5 &lt;线程23正在运行&gt; INSTANCE_5 &lt;线程22正在运行&gt; INSTANCE_5 &lt;线程24正在运行&gt; INSTANCE_5 &lt;线程21正在运行&gt;</p></blockquote><p>在这个例子中，<code>SingleInstance5</code> 是一个枚举类型，它只有一个实例 <code>INSTANCE</code>。由于枚举的特性，这个实例是线程安全的，并且在整个应用程序中都是唯一的。</p><p>要获取这个单例的实例，只需要调用 <code>SingleInstance5.INSTANCE</code>。要访问或修改它的属性，可以使用 <code>SingleInstance5.INSTANCE.setData(data)</code> 和 <code>SingleInstance5.INSTANCE.getData()</code> 方法。</p><p>关于序列化，由于枚举实例在反序列化时会被当作单个对象处理，因此不会出现重新创建实例的情况。也就是说，即使你尝试序列化并反序列化 <code>SingletonEnum.INSTANCE</code>，你得到的仍然是同一个实例。</p><p>使用枚举实现单例模式的好处是简单、高效且线程安全，不需要担心多线程环境下的竞态条件或其他同步问题。此外，由于枚举类型在Java中是特殊的类，它们不能被继承或反射实例化，这进一步增强了单例的安全性。</p><h2 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h2><h3 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点：&quot;">​</a></h3><ol><li><strong>节省资源</strong>：由于系统内存中只存在一个实例，因此可以节约系统资源，尤其是对于那些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li><strong>简化代码</strong>：单例模式提供了一个全局访问点，可以方便地在应用程序的任何地方访问该实例，无需频繁地创建和销毁对象，从而简化了代码。</li><li><strong>避免数据不一致</strong>：单例模式可以确保所有对象都访问同一个实例，从而避免了由于多个实例导致的数据不一致问题。</li></ol><h3 id="缺点" tabindex="-1">缺点： <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点：&quot;">​</a></h3><ol><li><strong>扩展性差</strong>：由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。如果需要扩展单例类的功能，通常需要修改源代码，这违反了开闭原则。</li><li><strong>职责过重</strong>：单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起，导致职责过重，在一定程度上违背了“单一职责原则”。</li><li><strong>线程安全问题</strong>：在多线程环境下，单例模式的实现需要考虑线程安全问题。如果实现不当，可能会导致多个实例被创建，从而引发数据不一致的问题。</li><li><strong>滥用可能导致问题</strong>：如果滥用单例模式，例如将数据库连接池设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li></ol><hr><p>代码相关代码可以参考 <strong><a href="https://gitee.com/jerrylau213/DesignPatterns" target="_blank" rel="noreferrer">代码仓库🌐</a></strong></p><p><strong>ps：本文原创，转载请注明出处</strong></p><hr>`,53),e=[t];function h(p,k,r,g,d,E){return a(),i("div",null,e)}const o=s(l,[["render",h]]);export{y as __pageData,o as default};
